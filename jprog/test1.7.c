#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define abs(a) (a>0?a:-a)
#define swap(a,b) (a ^= b ^= a ^= b)

int main () {
    //メモリ確保問題1.7
    double *x = malloc(sizeof(double));
    // あ、      ↓ に `&` がない理由とかはわかる?
    //xがポインタ変数だから？（文字のときにいらないのと一緒な感じ）↓文字列の先頭ポインタになるんだっけ　うむ
    // ですね、あってます（文字列 (char [n] / char*)(%s)の時にはいらないけど、文字(char)(%c)の時にはいる）
    // 文字列 == 文字の配列 の先頭ポインタですね
    // この理屈で行くと、int 配列の最初だけにscanfしたいときも、`&` はいらないというのがある（滅多に使うことないしわかりにくいのでやめたほうがいい()）
    //おー確かに　それはそう　次いって大丈夫 おっけーです
    scanf("%lf", x);
    printf("%lf\n", *x);
    // 動かしてみましょう
    //Ok?よっしゃ
    // ですね
    //*xに代入する形で書けば良かったのかー
    // 惜しかった感じなのね…
    //ううん全然違ったんだけど...いきなりmallocで書き始めたからこれもvoid型だと思いこんでたっぽい
    //ざっくり「ファイルを読み込む関数」とか「メモリ確保する関数」とかで覚えたのが悪かった
    // テストだと使えないけど、普通にPCで書くときは、関数名にマウスかざせば定義が出てくる…はず
    //ほんとだあint型って言われた　mallocの返り値がint型ってどういうこと？　↓！へー？voidでポインタ型と言われるとしっくりこないね
    // ポインタは整数なので一応 int ってことになってるんですかね（よく知らない）
    // (本当…というか、定義上は void* 型)
    // ポインタは特殊で、malloc() の後にいろんな型に入れられることになるので、`void` ってことにされてる
    //たしかに、double *xにint mallocってちょっと変だね
    // ちゃんと書くなら、
    // double *x = (double*)malloc(/**/);
    // って、キャストを書くことになる。ただ左辺から推測できるので省略できるみたいな…感じ
    //OK!
    // `double 型の大きさ` を埋めちゃいましょう
    return 0;
}
