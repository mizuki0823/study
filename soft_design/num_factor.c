#include <stdio.h>
#include <string.h>
#include <math.h>

#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define abs(a) (a>0?a:-a)
#define swap(a,b) (a ^= b ^= a ^= b)

int num_factor(int, int);

int main () {
    int result;
    int rem=10;
    int fac=2;
//10は2*5で２以上の素因数が２つあるからあってるっぽい
    // おしまい！いえええい３分法はあきらめた ええ
    // さっさとやりましょ
    //なんか〇〇関数を作れって言われると他に関数を
    result = num_factor(rem,fac);
    printf("計算結果：%d\n", result);

    return 0;
}
//ちょっと自分で考えて修正したのとコメント整理したわ
//num_factorがわかんないです
// :man_gesturing_ok:

//次の仕様を満たす関数num_factorを再帰的アルゴリズムで記述せよ。
//ただし，回答には関数の形のみで良く，プロトタイプ宣言やmain関数は必要ない。（回答する前には自身の環境で確かめること）

//引数は，2つの整数remとfacが与えられる。


//2,3,5,7で割っていって割れた数を配列に保存したら後で数えられるかなって思ったんだけどどうおうそうだわ
// あーなるほど、
// それよりも、「remに対してfacが素因数の一つであるかないかにより分岐するような構造にする。」でやることになるのよね（問題の指定があるので…）

// で、これやる時には、
// 次の素数を返す関数が欲しい
// 1 -> 2
// 2 -> 3
// 3 -> 5
// 5 -> 7
// ...
// (引数) -> (戻り値)
//素数の定義って自分と1以外で割れないだっけ
// だね、1からnまで、ループ回して、nまで割れなかったらおしまい（1） 割れたら素数じゃないのでそこでおしまい(0)
// 割れたら == 割り切れたら ==　あまりが 0 なら

//※n が素数かどうかを返す関数
// 素数の時 → 1
// 素数じゃない時 → 0
int so(int n){
    // そういえばここ 0 からだけど、1からで良い気がする←1で割ったら全部割れちゃうから2からかも
    for(int i=2; i<n; i++){
        if(n%i==0){
            //割れた
            return 0;
        }
    }
    //割れなかった
    return 1;
}

// 次の素数を返す関数
//素数ｎが引数なので、例えば素数＋１の値が素数だったら（１が引数だったら３を返したい）その値を返す
int next(int n){
    // こっちは、1ずつ増やしていって、それが素数だったらso() == 1だから…
    // n を1ずつ増やすので、iの最初のあたいは…？
    // 例えば n が8のとき、
    // 8 + 1 → 9 so(9) は 0 なので素数じゃない
    // … so(10) は 0なので素数じゃない
    // … so(11) は 1なので素数！
    // 戻り値が 11 になる
    // という感じ
    //nを1ずつ増やす？おー

    // 注意点
    // 11 のときは 11 ではなくて、13 を戻り値にしたい （next() の名前に合わせるとその方が良さそうなので）

    // n が素数だったら はどういう意味で書いてる？
    //remそのものが素数かどうか?

    // n -> 戻り値
    // 1 -> 2
    // 2 -> 3
    // 3 -> 5
    // 4 -> 5
    // 5 -> 7
    // 返す値が↑これなので、素数かどうかに関わらず、n+1以上で素数の数を返したい
    //ｎが別に素数じゃなくてもいいってこと？
    // そうだね、n を超えるもののうち、一番小さい素数を返したい
    // n は素数でなくても素数でもやる内容は変わらない気がしてます

        // 条件は、素数かどうかだね
        // for の()ところに「書かなくてもいい」==「if () break; でもいい」し、書いてもいい

    for(int i=n+1; ; i++){
        //n+1の値から素数をさがして見つかったら値を返してbreak
        if(so(i)==1){
            return i;
            // return したら、その下は決して実行されないのでなくて大丈夫ですね　OK
            // break;
        }
        // 素数が見つからないなら次の素数を求めて1を増やすことしかできんのや…
        //nextできあがり？
        // ですうい
    }
}


//num_factorは素因数値がfac以上であるremの 素因数の個数を返す。
//ただし， 素因数値は1より大きくrem以下とする。範囲外のfacが与えられた場合は0を返す。
//再帰的アルゴリズムへの適用については，remに対してfacが素因数の一つであるかないかにより分岐するような構造にする。
//例：
//num_factor(10, 2) //結果は2。10は2*5で2以上の 素因数値を持つ 素因数が2個あるため。
//num_factor(100, 2) //結果は4。10は2*2*5*5で2以上の 素因数値を持つ 素因数が4個あるため。
//num_factor(100, 5) //結果は2。10は2*2*5*5で5以上の 素因数値を持つ 素因数が2個あるため。
//num_factor(11, 2) //結果は1。11は11で2以上の 素因数値を持つ 素因数が1個あるため。

int num_factor(int rem, int fac){


    if(fac<=1 || fac>rem){
        return 0;
    }

    // 今は、fac が素数であるときしか例に出さなかったんですけど、
    // 再帰呼び出しではなくて、普通に一番最初に呼び出すときfac には素数以外の数が入っていることがありえます

    // だから、fac が 4のときは 5、3のときは3(のまま)にしたいです
    // 「この 3 のままにしたい」ですが、fac-1 に対しての次の素数を使うようにすれば、4-1 → 3→ 5、 3-1 → 2 → 3ができます
    //facが素数かどうかのifがいる？
    // 「「この 3 のままにしたい」ですが、fac-1 に対しての次の素数を使うようにすれば、4-1 → 3→ 5、 3-1 → 2 → 3ができます」これを使えばいらなくなります
    fac = next(fac-1);
    //こうだ
    // ok
    // テストしてみますか

    //これからどうするかがわからんくて
    // 仮に、rem が 100、 fac が 2とすると、
    // 100 は 2で割り切れるので、戻り値が増えることになります
    if(rem%fac==0) { // 100 は 2で割り切れるとき
        // 100 が 2で割り切れるので、戻り値は 1 + num_factor(50, 2) にしたいです。
        return(1+num_factor(rem/fac, fac));
    }
    // else{}hai
    // return しているので else は書かなくて ok です
    // そうしたら その次にはnum(25, 2)が呼ばれることになります
    // 25 は 2で割り切れないので、次の素数5(next関数を追加って取得できる)で割り切れるかチェックしたいです。
    // return num_factor(25, 5);

    // ちなみにこれ代入しないとダメです
    fac = next(fac);
    // 割り切れないのは 128 行目でチェックしているので確定してます
    // 
    //nextでfacの値が次の素数に変わって、再度チェックす
    //nextって次の（２から３）素数を返り値にしてるってことは関数を呼び出したあとその下でremに対して割り切れるか
    // > 「remに対して割り切れるか」これを確認していると無限に追加しなきゃ行けなくなってしまうのですが、
    // num_factor を新しくなった fac の値で呼び出すと 無限にチェックすることになります
    // おんなじことを書くんじゃなくて、書いてある関数を呼び出しましょうの回
    // 再度のチェックは、関数を呼び出したら、それでやっていることになります
    //facが更新されてるから今下の処理をすると結果が変わるのか
    // 多分それであってます
    return num_factor(rem,fac);

}